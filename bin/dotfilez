#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$'\n\t'

# ===========================
# Utilities & Styling
# ===========================
RESET="$(tput sgr0 || true)"
fg() {
  local name="${1^^}"
  case "$name" in
    BLACK)  tput setaf 0 2>/dev/null || true ;;
    RED)    tput setaf 1 2>/dev/null || true ;;
    GREEN)  tput setaf 2 2>/dev/null || true ;;
    YELLOW) tput setaf 3 2>/dev/null || true ;;
    BLUE)   tput setaf 4 2>/dev/null || true ;;
    MAGENTA|MAUVE) tput setaf 5 2>/dev/null || true ;;
    CYAN|PEACH)    tput setaf 6 2>/dev/null || true ;;
    WHITE)  tput setaf 7 2>/dev/null || true ;;
    *)      printf '' ;;
  esac
}
info() { printf '%s[+] %s%s\n' "$(fg GREEN)" "$*" "$RESET"; }
warn() { printf '%s[!] %s%s\n' "$(fg YELLOW)" "$*" "$RESET" >&2; }
err()  { printf '%s[✗] %s%s\n' "$(fg RED)" "$*" "$RESET" >&2; }
die()  { err "$*"; exit 1; }

trap 'err "Aborted at line $LINENO. Review logs; partial state possible."' ERR

have_cmd() { command -v "$1" >/dev/null 2>&1; }
script_abs() { readlink -f "$0"; }

# ---------------------------------------
# Banner
# ---------------------------------------
print_banner() {
  printf '\n'
  printf '%b  ██████╗ ███████╗██████╗ ████████╗     ██████╗ ███████╗██████╗ ██████╗ ███████╗██████╗ %b Infrastructure Installer %b\n' "$(fg RED)" "$(fg PEACH)" "$RESET"
  printf '%b ██╔════╝ ██╔════╝██╔══██╗╚══██╔══╝    ██╔════╝ ██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗%b by GertGerber %b\n' "$(fg RED)" "$(fg BLUE)" "$RESET"
  printf '%b ██║  ███╗█████╗  ██████╔╝   ██║       ██║  ███╗█████╗  ██████╔╝██████╔╝█████╗  ██████╔╝%b Setup your proxmox environment %b\n' "$(fg RED)" "$(fg MAUVE)" "$RESET"
  printf '%b ██║   ██║██╔══╝  ██╔══██╗   ██║       ██║   ██║██╔══╝  ██╔══██╗██╔══██╗██╔══╝  ██╔══██╗%b Enjoy homelab! 🚀%b\n' "$(fg RED)" "$(fg YELLOW)" "$RESET"
  printf '%b ╚██████╔╝███████╗██║  ██║   ██║       ╚██████╔╝███████╗██║  ██║██████╔╝███████╗██║  ██║%b Have fun with roles! 🎉%b\n' "$(fg RED)" "$(fg GREEN)" "$RESET"
  printf '%b  ╚═════╝ ╚══════╝╚═╝  ╚═╝   ╚═╝        ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝%b\n' "$(fg RED)" "$RESET"
  printf '\n'
}

# ===========================
# Root -> Create admin user -> Re-exec
# ===========================
ADMIN_GROUP_DEBIAN="sudo"
ADMIN_GROUP_RHEL="wheel"

validate_username() {
  local u="$1"
  [[ "$u" =~ ^[a-z_][a-z0-9_-]{0,31}$ ]]
}

detect_admin_group() {
  if have_cmd adduser; then
    echo "$ADMIN_GROUP_DEBIAN"
  else
    echo "$ADMIN_GROUP_RHEL"
  fi
}

ensure_sudo_installed() {
  if have_cmd sudo; then return; fi
  info "Installing sudo..."
  apt-get update -y
  DEBIAN_FRONTEND=noninteractive apt-get install -y sudo
}

create_admin_user_if_root() {
  local as_user_flag="${1:-}"
  if [[ $EUID -ne 0 ]]; then
    return 0
  fi
  # If we explicitly came back as user, skip creation
  if [[ "$as_user_flag" == "--as-user" ]]; then
    return 0
  fi

  print_banner
  info "You are running as root. Let's create your non-root admin user."

  local USERNAME=""
  while :; do
    read -r -p "Enter new admin username (e.g., gert): " USERNAME
    if [[ -z "${USERNAME:-}" ]]; then
      warn "Username cannot be empty."
      continue
    fi
    if ! validate_username "$USERNAME"; then
      warn "Invalid username. Use lowercase letters, digits, _ or -, max length 32, starting with a letter or _."
      continue
    fi
    if id "$USERNAME" &>/dev/null; then
      warn "User '$USERNAME' already exists."
      read -r -p "Use existing user '$USERNAME'? [y/N]: " yn
      case "${yn,,}" in
        y|yes) break ;;
        *) continue ;;
      esac
    fi
    break
  done

  # Create if missing
  if ! id "$USERNAME" &>/dev/null; then
    if have_cmd adduser; then
      info "Creating user '$USERNAME' (Debian/Ubuntu path)..."
      adduser --gecos "" "$USERNAME"
    elif have_cmd useradd; then
      info "Creating user '$USERNAME' (RHEL/Fedora path)..."
      useradd --create-home --shell /bin/bash "$USERNAME"
      info "Set a password for '$USERNAME':"
      passwd "$USERNAME"
    else
      die "Neither adduser nor useradd found."
    fi
  fi

  ensure_sudo_installed

  local ADMIN_GROUP
  ADMIN_GROUP="$(detect_admin_group)"
  if getent group "$ADMIN_GROUP" >/dev/null 2>&1; then
    usermod -aG "$ADMIN_GROUP" "$USERNAME"
    info "Added '$USERNAME' to '$ADMIN_GROUP'."
  else
    warn "Admin group '$ADMIN_GROUP' not found; creating and assigning."
    groupadd "$ADMIN_GROUP"
    usermod -aG "$ADMIN_GROUP" "$USERNAME"
  fi

  # Ensure the user can sudo without PATH issues
  echo "$USERNAME ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/apt, /usr/bin/nala, /usr/bin/gh, /usr/bin/git" >/etc/sudoers.d/90-${USERNAME}-bootstrap
  chmod 440 /etc/sudoers.d/90-${USERNAME}-bootstrap
  info "Granted limited passwordless sudo for bootstrap commands."

  # Re-exec this script as the new user
  local SELF
  SELF="$(script_abs)"
  info "Re-running the installer as '$USERNAME'..."
  exec su -l "$USERNAME" -c "bash -lc 'bash \"$SELF\" --as-user'"
}

# ===========================
# Package Management (uses sudo when not root)
# ===========================
PKG_TOOL="apt"
USE_NALA=false

_sudo() {
  if [[ $EUID -eq 0 ]]; then
    "$@"
  else
    sudo "$@"
  fi
}

install_nala_if_missing() {
  if have_cmd nala; then
    USE_NALA=true
    PKG_TOOL="nala"
    return
  fi

  info "Installing nala (faster apt frontend)..."
  _sudo apt-get update -y
  if DEBIAN_FRONTEND=noninteractive _sudo apt-get install -y nala; then
    USE_NALA=true
    PKG_TOOL="nala"
    info "nala installed."
  else
    warn "Failed to install nala; will fall back to apt."
    USE_NALA=false
    PKG_TOOL="apt"
  fi
}

pkg_update_upgrade() {
  if $USE_NALA; then
    info "Updating & upgrading via nala..."
    _sudo nala update
    DEBIAN_FRONTEND=noninteractive _sudo nala upgrade -y
  else
    info "Updating & upgrading via apt..."
    _sudo apt-get update -y
    DEBIAN_FRONTEND=noninteractive _sudo apt-get upgrade -y
  fi
}

pkg_install() {
  local pkgs=("$@")
  if $USE_NALA; then
    DEBIAN_FRONTEND=noninteractive _sudo nala install -y "${pkgs[@]}" || {
      warn "nala install failed; retrying with apt..."
      DEBIAN_FRONTEND=noninteractive _sudo apt-get install -y "${pkgs[@]}"
    }
  else
    DEBIAN_FRONTEND=noninteractive _sudo apt-get install -y "${pkgs[@]}"
  fi
}

# ===========================
# Env & Inputs
# ===========================
# ENV_FILE="/etc/dotfilez.env"
ENV_FILE="$HOME/.cache/etc/dotfilez.env"

load_env_if_present() {
  if [[ -f "$ENV_FILE" ]]; then
    # shellcheck disable=SC1090
    _sudo bash -lc "source \"$ENV_FILE\"" || true
    # Also source in current shell if readable
    if [[ -r "$ENV_FILE" ]]; then
      # shellcheck disable=SC1090
      source "$ENV_FILE"
      info "Loaded existing env from $ENV_FILE"
    fi
  fi
}

ask_or_keep() {
  local var_name="$1" prompt="$2"
  local current="${!var_name:-}"
  if [[ -n "$current" ]]; then
    read -r -p "$prompt [$current]: " input || true
    export "$var_name"="${input:-$current}"
  else
    read -r -p "$prompt: " input
    export "$var_name"="$input"
  fi
}

save_env() {
  umask 0177
  local tmp_file
  tmp_file="$(mktemp)"
  cat >"$tmp_file" <<EOF
GIT_NAME=${GIT_NAME}
GIT_EMAIL=${GIT_EMAIL}
GITHUB_TOKEN=${GITHUB_TOKEN}
EOF
  _sudo mv "$tmp_file" "$ENV_FILE"
  _sudo chmod 600 "$ENV_FILE"
  info "Saved machine variables to $ENV_FILE"

# Ensure exported
  export GIT_NAME GIT_EMAIL GITHUB_TOKEN
}

# ===========================
# Git & GitHub Setup
# ===========================
ensure_gh() {
  if have_cmd gh; then
    info "GitHub CLI (gh) already present."
    return
  fi

  info "Installing GitHub CLI (gh)..."
  # Call the function directly; it wraps sudo internally.
  if pkg_install gh; then
    info "Installed gh via ${PKG_TOOL}."
  else
    warn "Native package 'gh' not found; setting up GitHub apt repo..."
    # Debian/Ubuntu path: add official GitHub CLI repo and install
    _sudo apt-get update -y
    _sudo apt-get install -y curl ca-certificates gnupg
    _sudo mkdir -p -m 755 /etc/apt/keyrings
    curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
      | _sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg >/dev/null
    _sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg
    # shellcheck disable=SC1091
    . /etc/os-release
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages ${VERSION_CODENAME} main" \
      | _sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
    _sudo apt-get update -y
    _sudo apt-get install -y gh || die "Failed to install GitHub CLI."
  fi
}

configure_git_and_gh() {
  # fail fast on missing deps
  command -v git >/dev/null 2>&1 || die "git is not installed."
  command -v gh  >/dev/null 2>&1 || die "GitHub CLI (gh) is not installed."

  # inputs
  : "${GIT_NAME:?GIT_NAME is empty.}"
  : "${GIT_EMAIL:?GIT_EMAIL is empty.}"
  : "${GITHUB_TOKEN:?GITHUB_TOKEN is empty.}"

  info "Configuring git user identity (global)..."
  git config --global user.name  "$GIT_NAME"
  git config --global user.email "$GIT_EMAIL"
  # optional sensible defaults:
  git config --global init.defaultBranch main >/dev/null 2>&1 || true
  git config --global pull.rebase false        >/dev/null 2>&1 || true

  # don’t leak secrets if -x is on
  shopt -qo xtrace && _TRACE_ON=1 || _TRACE_ON=0
  [ "$_TRACE_ON" -eq 1 ] && set +x

  info "Logging into GitHub CLI via token..."
  # prefer GH_TOKEN (what gh uses); set it temporarily in env for this pipeline only
  GH_TOKEN="$GITHUB_TOKEN" printf '%s' "$GITHUB_TOKEN" | gh auth login --with-token --hostname github.com

  # restore tracing
  [ "$_TRACE_ON" -eq 1 ] && set -x

  # verify auth and set up git credential helper
  gh auth status --hostname github.com || die "GitHub auth failed."
  gh auth setup-git >/dev/null 2>&1 || true

  # optional: sanity check scopes (non-fatal)
  gh api user >/dev/null 2>&1 || warn "Token may lack required scopes."

  # optional: avoid leaving token in env
  unset GH_TOKEN
  # keep GITHUB_TOKEN exported only if other tooling needs it; else:
  # unset GITHUB_TOKEN

  success "Git and GitHub CLI are configured."
}



# ===========================
# Clone Repo
# ===========================
REPO_URL="https://github.com/GertGerber/dotfilez"
CLONE_DIR="/opt/dotfilez"

clone_or_update_repo() {
  if [[ -d "$CLONE_DIR/.git" ]]; then
    info "Repository already present; pulling latest."
    _sudo git -C "$CLONE_DIR" remote set-url origin "$REPO_URL" || true
    _sudo git -C "$CLONE_DIR" fetch --all --prune
    _sudo git -C "$CLONE_DIR" pull --ff-only
    # ensure current user owns workspace
    _sudo chown -R "$(id -u)":"$(id -g)" "$CLONE_DIR"
  else
    info "Cloning repository into $CLONE_DIR ..."
    _sudo mkdir -p "$CLONE_DIR"
    _sudo chown "$(id -u)":"$(id -g)" "$CLONE_DIR"
    git clone "$REPO_URL" "$CLONE_DIR"
  fi
}

# ===========================
# Post-Clone Hooks
# ===========================
post_clone_actions() {
  info "Post-clone actions section (customize as needed)."
  # Example hook: run create_user.sh if it exists and is executable
  if [[ -x "$CLONE_DIR/create_user.sh" ]]; then
    warn "About to run: $CLONE_DIR/create_user.sh (press Enter to continue or Ctrl+C to skip)"
    read -r _
    bash "$CLONE_DIR/create_user.sh" || warn "create_user.sh exited with non-zero status."
  else
    warn "No create_user.sh found at $CLONE_DIR; skipping user creation step."
  fi
}

# ===========================
# Main (user-mode)
# ===========================
PKG_WANTS=(git ca-certificates)
ENV_FILE="/etc/dotfilez.env"

main_user_mode() {
  print_banner

  # Make sure sudo is usable (will prompt once if NOPASSWD not set)
  if [[ $EUID -ne 0 ]]; then
    if ! have_cmd sudo; then
      die "sudo not available; please run as root first so I can install it."
    fi
    sudo -v || die "Unable to obtain sudo privileges."
  fi

  install_nala_if_missing
  pkg_update_upgrade
  pkg_install "${PKG_WANTS[@]}"

  # Gather env (persisted)
  load_env_if_present
  ask_or_keep "GIT_NAME" "Enter your Git Name"
  ask_or_keep "GIT_EMAIL" "Enter your Git Email"
  ask_or_keep "GITHUB_TOKEN" "Enter your GitHub Personal Access Token (stored in $ENV_FILE)"
  save_env

  # NEW: reload the saved environment
  if [[ -r "$ENV_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$ENV_FILE"
    info "Reloaded $ENV_FILE into current environment"
  fi

  # GitHub CLI + auth
  ensure_gh
  configure_git_and_gh

  # Clone repo
  clone_or_update_repo

  # Post-clone section
  post_clone_actions

  info "All done. This LXC is now primed as your homelab deployment server. 🚀"
}

# ===========================
# Entrypoint
# ===========================
AS_USER_FLAG="${1:-}"
create_admin_user_if_root "$AS_USER_FLAG"
main_user_mode
