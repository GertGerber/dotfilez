#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$'\n\t'

# =====================================================================================
# Proxmox LXC Infrastructure Installer (Debian/Ubuntu)
# - Idempotent, safe sudoers handling, resilient apt, env-preserving re-exec
# - Minimal prompts: only asks for USERNAME, GIT_NAME, GIT_EMAIL, GITHUB_TOKEN if missing
# - Non-interactive mode via --non-interactive and/or preseeded env vars
# - Emits a machine-readable JSON summary for audit/automation
# =====================================================================================

# ===========================
# Utilities & Styling
# ===========================
RESET="$(tput sgr0 || true)"
fg() {
  local name="${1^^}"
  case "$name" in
    BLACK)  tput setaf 0 2>/dev/null || true ;;
    RED)    tput setaf 1 2>/dev/null || true ;;
    GREEN)  tput setaf 2 2>/dev/null || true ;;
    YELLOW) tput setaf 3 2>/dev/null || true ;;
    BLUE)   tput setaf 4 2>/dev/null || true ;;
    MAGENTA|MAUVE) tput setaf 5 2>/dev/null || true ;;
    CYAN|PEACH)    tput setaf 6 2>/dev/null || true ;;
    WHITE)  tput setaf 7 2>/dev/null || true ;;
    *)      printf '' ;;
  esac
}
info() { printf '%s[+] %s%s\n' "$(fg GREEN)" "$*" "$RESET"; }
warn() { printf '%s[!] %s%s\n' "$(fg YELLOW)" "$*" "$RESET" >&2; }
err()  { printf '%s[✗] %s%s\n' "$(fg RED)" "$*" "$RESET" >&2; }
die()  { err "$*"; exit 1; }
is_tty() { [[ -t 0 ]]; }

trap 'err "Aborted at line $LINENO. Review logs; partial state possible."' ERR

have_cmd()   { command -v "$1" >/dev/null 2>&1; }
script_abs() {
  if have_cmd readlink; then readlink -f "$0"; elif have_cmd realpath; then realpath "$0"; else
    # Fallback (works in typical Linux shells)
    python3 - <<'PY' 2>/dev/null || printf '%s' "$0"
import os,sys
print(os.path.abspath(sys.argv[1]))
PY
  fi
}
json_escape() { python3 -c 'import json,sys; print(json.dumps(sys.stdin.read()))'; }

# ---------------------------------------
# Banner
# ---------------------------------------
print_banner() {
  printf '\n'
  printf '%b  ██████╗ ███████╗██████╗ ████████╗     ██████╗ ███████╗██████╗ ██████╗ ███████╗██████╗ %b Infrastructure Installer %b\n' "$(fg RED)" "$(fg PEACH)" "$RESET"
  printf '%b ██╔════╝ ██╔════╝██╔══██╗╚══██╔══╝    ██╔════╝ ██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗%b by GertGerber %b\n' "$(fg RED)" "$(fg BLUE)" "$RESET"
  printf '%b ██║  ███╗█████╗  ██████╔╝   ██║       ██║  ███╗█████╗  ██████╔╝██████╔╝█████╗  ██████╔╝%b Setup your proxmox environment %b\n' "$(fg RED)" "$(fg MAUVE)" "$RESET"
  printf '%b ██║   ██║██╔══╝  ██╔══██╗   ██║       ██║   ██║██╔══╝  ██╔══██╗██╔══██╗██╔══╝  ██╔══██╗%b Enjoy homelab! 🚀%b\n' "$(fg RED)" "$(fg YELLOW)" "$RESET"
  printf '%b ╚██████╔╝███████╗██║  ██║   ██║       ╚██████╔╝███████╗██║  ██║██████╔╝███████╗██║  ██║%b Have fun with roles! 🎉%b\n' "$(fg RED)" "$(fg GREEN)" "$RESET"
  printf '%b  ╚═════╝ ╚══════╝╚═╝  ╚═╝   ╚═╝        ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝%b\n' "$(fg RED)" "$RESET"
  printf '\n'
}

# ==========================
# Detect OS
# ==========================
detect_os() {
  if [[ -r /etc/os-release ]]; then
    . /etc/os-release
    case "${ID:-}" in
      debian|ubuntu|linuxmint) echo debian ;;
      rhel|centos|rocky|almalinux|fedora) echo rhel ;;
      *) echo debian ;;
    esac
  else
    echo debian
  fi
}
PKG_FAMILY="$(detect_os)"

require_debian() {
  [[ "$PKG_FAMILY" == debian ]] || die "Unsupported OS family: $PKG_FAMILY (Debian/Ubuntu only)."
}

# ===========================
# Root -> Create admin user -> Re-exec
# ===========================
ADMIN_GROUP_DEBIAN="sudo"
ADMIN_GROUP_RHEL="wheel"

validate_username() { local u="$1"; [[ "$u" =~ ^[a-z_][a-z0-9_-]{0,31}$ ]]; }

detect_admin_group() { [[ "$PKG_FAMILY" == debian ]] && echo "$ADMIN_GROUP_DEBIAN" || echo "$ADMIN_GROUP_RHEL"; }

ensure_sudo_installed() {
  have_cmd sudo && return 0
  info "Installing sudo..."
  require_debian
  apt-get -o Acquire::Retries=3 update -y
  DEBIAN_FRONTEND=noninteractive apt-get install -y sudo
}

# Preserve colour/locale when re-execing as target user
reexec_as_user() {
  local user="$1" self; self="$(script_abs)"
  info "Re-running the installer as '$user'..."
  local keep="TERM,COLORTERM,LANG,LC_ALL"; export LANG="${LANG:-C.UTF-8}" TERM="${TERM:-xterm}"
  if command -v sudo >/dev/null 2>&1; then
    exec sudo -iu "$user" --preserve-env="$keep" bash -lc "bash '$self' --as-user ${NON_INTERACTIVE:+--non-interactive}"
  else
    exec su -l "$user" -c "TERM='$TERM' LANG='$LANG' bash -lc 'bash \"$self\" --as-user ${NON_INTERACTIVE:+--non-interactive}'"
  fi
}

create_admin_user_if_root() {
  local as_user_flag="${1:-}"
  if [[ $EUID -ne 0 ]]; then return 0; fi
  [[ "$as_user_flag" == "--as-user" ]] && return 0
  require_debian

  print_banner
  info "You are running as root. We'll create a non-root admin user."
  is_tty || die "Non-interactive shell detected. Please run with a TTY to create the admin user, or preseed USERNAME."

  local USERNAME_INPUT="${USERNAME:-}"
  local USERNAME_CHOSEN=""
  while :; do
    if [[ -n "$USERNAME_INPUT" ]]; then
      USERNAME_CHOSEN="$USERNAME_INPUT"
      info "Using provided USERNAME='$USERNAME_CHOSEN'"
    else
      read -r -p "Enter new admin username (e.g., gert): " USERNAME_INPUT
      [[ -z "${USERNAME_INPUT:-}" ]] && { warn "Username cannot be empty."; continue; }
    fi
    if ! validate_username "$USERNAME_INPUT"; then warn "Invalid username. Use lowercase letters, digits, _ or -, max 32, starting with a letter or _."; USERNAME_INPUT=""; continue; fi
    USERNAME_CHOSEN="$USERNAME_INPUT"; break
  done
  export USERNAME="$USERNAME_CHOSEN"

  ensure_sudo_installed

  if id "$USERNAME" &>/dev/null; then
    info "User '$USERNAME' already exists."
  else
    if have_cmd adduser; then
      info "Creating user '$USERNAME' (Debian/Ubuntu path)..."
      adduser --disabled-password --gecos "" "$USERNAME"
      if is_tty; then
        info "Set a password for '$USERNAME':"; passwd "$USERNAME" || warn "Password not set."
      else
        warn "Non-interactive: leaving '$USERNAME' with disabled password."
      fi
    elif have_cmd useradd; then
      info "Creating user '$USERNAME' (RHEL/Fedora path)..."
      useradd --create-home --shell /bin/bash "$USERNAME"
      is_tty && { info "Set a password for '$USERNAME':"; passwd "$USERNAME" || true; }
    else
      die "Neither adduser nor useradd found."
    fi
  fi

  local ADMIN_GROUP; ADMIN_GROUP="$(detect_admin_group)"
  if getent group "$ADMIN_GROUP" >/dev/null 2>&1; then
    usermod -aG "$ADMIN_GROUP" "$USERNAME"
    info "Added '$USERNAME' to '$ADMIN_GROUP'."
  else
    warn "Admin group '$ADMIN_GROUP' not found; creating and assigning."
    groupadd "$ADMIN_GROUP"; usermod -aG "$ADMIN_GROUP" "$USERNAME"
  fi

  # Limited passwordless sudo for bootstrap commands — validate first
  local tmp_sudo="/tmp/90-${USERNAME}-bootstrap.$$"
  cat >"$tmp_sudo" <<EOF
${USERNAME} ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/apt, /usr/bin/nala, /usr/bin/gh, /usr/bin/git
EOF
  if visudo -cf "$tmp_sudo" >/dev/null 2>&1; then
    install -m 0440 "$tmp_sudo" "/etc/sudoers.d/90-${USERNAME}-bootstrap"
    info "Granted limited passwordless sudo for bootstrap commands."
  else
    rm -f "$tmp_sudo"; die "Refusing to install sudoers snippet; visudo validation failed."
  fi

  reexec_as_user "$USERNAME"
}

# ===========================
# Package Management (uses sudo when not root)
# ===========================
PKG_TOOL="apt"
USE_NALA=false

_sudo() { if [[ $EUID -eq 0 ]]; then "$@"; else sudo "$@"; fi }

install_nala_if_missing() {
  [[ "$PKG_FAMILY" == debian ]] || { warn "Non-Debian OS detected; skipping nala/apt-specific steps."; return 0; }
  if have_cmd nala; then USE_NALA=true; PKG_TOOL="nala"; return; fi
  info "Installing nala (faster apt frontend)..."
  _sudo apt-get -o Acquire::Retries=3 update -y
  if DEBIAN_FRONTEND=noninteractive _sudo apt-get install -y nala; then
    USE_NALA=true; PKG_TOOL="nala"; info "nala installed."
  else
    warn "Failed to install nala; will fall back to apt."; USE_NALA=false; PKG_TOOL="apt"
  fi
}

pkg_update_upgrade() {
  require_debian
  if $USE_NALA; then
    info "Updating & upgrading via nala..."
    _sudo nala update
    DEBIAN_FRONTEND=noninteractive _sudo nala upgrade -y
  else
    info "Updating & upgrading via apt..."
    _sudo apt-get -o Acquire::Retries=3 update -y
    DEBIAN_FRONTEND=noninteractive _sudo apt-get upgrade -y
  fi
}

pkg_install() {
  local pkgs=("$@")
  require_debian
  if $USE_NALA; then
    DEBIAN_FRONTEND=noninteractive _sudo nala install -y "${pkgs[@]}" || {
      warn "nala install failed; retrying with apt..."
      DEBIAN_FRONTEND=noninteractive _sudo apt-get install -y "${pkgs[@]}"
    }
  else
    DEBIAN_FRONTEND=noninteractive _sudo apt-get install -y "${pkgs[@]}"
  fi
}

# ===========================
# Env & Inputs
# ===========================
ENV_FILE="${ENV_FILE:-$HOME/.config/dotfilez/env}"
NON_INTERACTIVE=false

create_env_file_if_missing() {
  if [[ ! -f "$ENV_FILE" ]]; then
    info "Creating $ENV_FILE ..."
    mkdir -p "$(dirname "$ENV_FILE")"
    echo "# dotfilez environment configuration" > "$ENV_FILE"
    chmod 600 "$ENV_FILE"
  fi
}

load_env_if_present() { [[ -f "$ENV_FILE" ]] && { # shellcheck disable=SC1090
  source "$ENV_FILE" || true; info "Loaded existing env from $ENV_FILE"; } }

# Only prompt if var is unset/empty; otherwise keep current value
ask_if_missing() {
  local var_name="$1" prompt="$2" secret="${3:-}"
  local current="${!var_name:-}"
  if [[ -n "$current" ]]; then export "$var_name"="$current"; return 0; fi
  if $NON_INTERACTIVE || ! is_tty; then die "Missing required $var_name and no TTY to prompt. Preseed it in env or run interactively."; fi
  local input
  if [[ "$secret" == "secret" ]]; then
    read -rs -p "$prompt: " input; echo
  else
    read -r -p "$prompt: " input
  fi
  export "$var_name"="$input"
}

save_env() {
  create_env_file_if_missing
  umask 0177
  local tmp_file; tmp_file="$(mktemp)"
  cat >"$tmp_file" <<EOF
GIT_NAME=${GIT_NAME}
GIT_EMAIL=${GIT_EMAIL}
GITHUB_TOKEN=${GITHUB_TOKEN:-}
USERNAME=${USERNAME:-}
EOF
  mv "$tmp_file" "$ENV_FILE"; chmod 600 "$ENV_FILE"
  info "Saved machine variables to $ENV_FILE"
  export GIT_NAME GIT_EMAIL GITHUB_TOKEN USERNAME
}

# ===========================
# Git & GitHub Setup
# ===========================
ensure_gh() {
  if have_cmd gh; then info "GitHub CLI (gh) already present."; return; fi
  info "Installing GitHub CLI (gh)..."
  if pkg_install gh; then info "Installed gh via ${PKG_TOOL}."; return; fi
  warn "Native package 'gh' not found; setting up GitHub apt repo..."
  _sudo apt-get -o Acquire::Retries=3 update -y
  _sudo apt-get install -y curl ca-certificates gnupg
  _sudo mkdir -p -m 755 /etc/apt/keyrings
  curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
    | _sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg >/dev/null
  _sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg
  . /etc/os-release || true; : "${VERSION_CODENAME:=stable}"
  echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages ${VERSION_CODENAME} main" \
    | _sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
  _sudo apt-get -o Acquire::Retries=3 update -y || die "apt update failed after adding GitHub CLI repo."
  _sudo apt-get install -y gh || die "Failed to install GitHub CLI."
}

configure_git() {
  command -v git >/dev/null 2>&1 || die "git is not installed."
  : "${GIT_NAME:?GIT_NAME is empty.}"; : "${GIT_EMAIL:?GIT_EMAIL is empty.}"
  info "Configuring git user identity (global)..."
  git config --global user.name  "$GIT_NAME"
  git config --global user.email "$GIT_EMAIL"
  git config --global init.defaultBranch main >/dev/null 2>&1 || true
  git config --global pull.rebase false        >/dev/null 2>&1 || true
  info "Git is configured."
}

prompt_github_token() {
  $NON_INTERACTIVE && return 1
  is_tty || return 1
  local token
  echo -n "[?] Enter your GitHub Personal Access Token (input hidden): " >&2
  read -rs token; echo >&2
  [[ -z "$token" ]] && return 1
  printf '%s' "$token"
}

gh_login_store_token() {
  local token="${GITHUB_TOKEN:-${GH_TOKEN:-}}"
  if [[ -z "$token" ]]; then token="$(prompt_github_token || true)" || true; fi
  if [[ -z "$token" ]]; then warn "No token provided; continuing without authenticated gh."; return 0; fi
  if gh auth status -h github.com >/dev/null 2>&1; then info "gh already authenticated to github.com"; gh auth setup-git || true; return 0; fi
  info "Logging into GitHub CLI and storing credentials…"
  local saved_token="$token"; unset GITHUB_TOKEN GH_TOKEN
  gh auth logout -h github.com -y >/dev/null 2>&1 || true
  if ! printf '%s' "$saved_token" | gh auth login --hostname github.com --with-token; then
    warn "gh auth login failed; leaving token in env for other tooling."; export GITHUB_TOKEN="$saved_token"; return 1
  fi
  gh auth setup-git || true
  export GITHUB_TOKEN="$saved_token"
  if ! gh api -H "Accept: application/vnd.github+json" /user >/dev/null 2>&1; then warn "Token may lack scopes for /user."; fi
  gh auth status -h github.com >/dev/null 2>&1 || warn "gh auth status check failed after login."
  info "gh authentication configured."
}

# ===========================
# Clone Repo
# ===========================
REPO_URL="${REPO_URL:-https://github.com/GertGerber/dotfilez}"
CLONE_DIR="${CLONE_DIR:-$HOME/dotfilez}"

clone_via_gh() {
set -x
  # Usage: git_sync_repo <repo-url> <dest-dir> [branch]
  # Example: git_sync_repo https://github.com/user/project.git ~/project main
  local repo_url="${1:?repo url required}"
  local dest_dir="${2:?destination directory required}"
  local branch="${3:-}"

  if [[ -d "$dest_dir/.git" ]]; then
    # Already a git repo: verify remote, then update
    local current_remote
    current_remote="$(git -C "$dest_dir" remote get-url origin 2>/dev/null || true)"
    if [[ -z "$current_remote" ]]; then
      echo "origin remote is missing in $dest_dir" >&2
      return 1
    fi
    # Normalise https URL with/without .git for comparison
    local norm_repo="${repo_url%.git}"
    local norm_remote="${current_remote%.git}"
    if [[ "$norm_remote" != "$norm_repo" && "$current_remote" != "git@github.com:${norm_repo#https://github.com/}.git" ]]; then
      echo "destination exists but points to a different remote: $current_remote" >&2
      return 1
    fi

    # Fetch and fast-forward only (refuse to overwrite local changes)
    git -C "$dest_dir" fetch --tags --prune || return 1
    if [[ -n "$branch" ]]; then
      git -C "$dest_dir" checkout "$branch" || return 1
      git -C "$dest_dir" merge --ff-only "origin/$branch" || return 1
    else
      # Update the current branch
      git -C "$dest_dir" pull --ff-only || return 1
    fi
    echo "Updated: $dest_dir"
  else
    # Not a repo: clone (into empty or non-existent dir)
    mkdir -p "$(dirname "$dest_dir")" || return 1
    if [[ -e "$dest_dir" && -n "$(ls -A "$dest_dir" 2>/dev/null)" ]]; then
      echo "destination directory exists and is not a git repo (non-empty): $dest_dir" >&2
      return 1
    fi
    if [[ -n "$branch" ]]; then
      git clone --branch "$branch" --depth 1 "$repo_url" "$dest_dir" || return 1
    else
      git clone --depth 1 "$repo_url" "$dest_dir" || return 1
    fi
    echo "Cloned: $repo_url -> $dest_dir"
  fi
set +x
}


# ===========================
# Post-Clone Hooks
# ===========================
post_clone_actions() {
  info "Post-clone actions section (customise as needed)."
  if ! is_tty; then warn "No TTY; skipping interactive post-clone steps."; return 0; fi
  if [[ -x "$CLONE_DIR/create_user.sh" ]]; then
    warn "About to run: $CLONE_DIR/create_user.sh (press Enter to continue or Ctrl+C to skip)"; read -r _ || true; bash "$CLONE_DIR/create_user.sh" || warn "create_user.sh exited with non-zero status."
  else
    warn "No create_user.sh found at $CLONE_DIR; skipping user creation step."
  fi
}

# ===========================
# Summary Output
# ===========================
write_summary() {
  local summary_path="${SUMMARY_PATH:-/var/tmp/infra-installer-summary.json}"
  local gh_status="unauthenticated"; if gh auth status -h github.com >/dev/null 2>&1; then gh_status="authenticated"; fi
  local data
  data=$(cat <<JSON
{
  "timestamp": "$(date -Is)",
  "user": "${USER:-$USERNAME:-unknown}",
  "username": "${USERNAME:-}",
  "pkg_family": "${PKG_FAMILY}",
  "pkg_tool": "${PKG_TOOL}",
  "use_nala": ${USE_NALA},
  "git": {"name": "${GIT_NAME:-}", "email": "${GIT_EMAIL:-}"},
  "gh": {"status": "${gh_status}"},
  "repo": {"url": "${REPO_URL}", "dir": "${CLONE_DIR}"}
}
JSON
)
  printf '%s' "$data" > "$summary_path"
  info "Wrote summary to $summary_path"
}

# ===========================
# Main (user-mode)
# ===========================
PKG_WANTS=(git ca-certificates)

main_user_mode() {
  print_banner
  require_debian

  # Make sure sudo is usable (will prompt once if NOPASSWD not set)
  if [[ $EUID -ne 0 ]]; then
    if ! have_cmd sudo; then die "sudo not available; please run as root first so we can install it."; fi
    sudo -v || die "Unable to obtain sudo privileges."
  fi

  install_nala_if_missing
  pkg_update_upgrade
  pkg_install "${PKG_WANTS[@]}"

  # Gather env (persisted)
  load_env_if_present
  ask_if_missing "GIT_NAME"  "Enter your Git Name"
  ask_if_missing "GIT_EMAIL" "Enter your Git Email"
  # Token is optional, but if provided we persist it and use for gh
  if [[ -z "${GITHUB_TOKEN:-}" && ! $NON_INTERACTIVE && is_tty ]]; then
    read -rs -p "(Optional) Enter your GitHub PAT to auth gh (input hidden, Enter to skip): " GITHUB_TOKEN || true; echo || true
  fi
  save_env

  # Reload for current session
  if [[ -r "$ENV_FILE" ]]; then source "$ENV_FILE"; info "Reloaded $ENV_FILE into current environment"; fi

  ensure_gh
  configure_git
  gh_login_store_token || warn "GitHub auth not completed; proceeding."

  clone_via_gh "$REPO_URL" "$CLONE_DIR" main

  post_clone_actions

  write_summary

  info "All done. This LXC is now primed as your homelab deployment server. 🚀"
}

# ===========================
# CLI Args & Entrypoint
# ===========================
AS_USER_FLAG=""; for a in "$@"; do case "$a" in --as-user) AS_USER_FLAG="--as-user";; --non-interactive) NON_INTERACTIVE=true;; esac; done

create_admin_user_if_root "$AS_USER_FLAG"
main_user_mode
