#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$'\n\t'

# ===========================
# Utilities & Styling
# ===========================
RESET="$(tput sgr0 || true)"
fg() {
  local name="${1^^}"
  case "$name" in
    BLACK)  tput setaf 0 2>/dev/null || true ;;
    RED)    tput setaf 1 2>/dev/null || true ;;
    GREEN)  tput setaf 2 2>/dev/null || true ;;
    YELLOW) tput setaf 3 2>/dev/null || true ;;
    BLUE)   tput setaf 4 2>/dev/null || true ;;
    MAGENTA|MAUVE) tput setaf 5 2>/dev/null || true ;;
    CYAN|PEACH)    tput setaf 6 2>/dev/null || true ;;
    WHITE)  tput setaf 7 2>/dev/null || true ;;
    *)      printf '' ;;
  esac
}
info() { printf '%s[+] %s%s\n' "$(fg GREEN)" "$*" "$RESET"; }
warn() { printf '%s[!] %s%s\n' "$(fg YELLOW)" "$*" "$RESET" >&2; }
err()  { printf '%s[✗] %s%s\n' "$(fg RED)" "$*" "$RESET" >&2; }
die()  { err "$*"; exit 1; }
is_tty() { [[ -t 0 ]]; }

trap 'err "Aborted at line $LINENO. Review logs; partial state possible."' ERR

have_cmd()   { command -v "$1" >/dev/null 2>&1; }
script_abs() { readlink -f "$0"; }

# ---------------------------------------
# Banner
# ---------------------------------------
print_banner() {
  printf '\n'
  printf '%b  ██████╗ ███████╗██████╗ ████████╗     ██████╗ ███████╗██████╗ ██████╗ ███████╗██████╗ %b Infrastructure Installer %b\n' "$(fg RED)" "$(fg PEACH)" "$RESET"
  printf '%b ██╔════╝ ██╔════╝██╔══██╗╚══██╔══╝    ██╔════╝ ██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗%b by GertGerber %b\n' "$(fg RED)" "$(fg BLUE)" "$RESET"
  printf '%b ██║  ███╗█████╗  ██████╔╝   ██║       ██║  ███╗█████╗  ██████╔╝██████╔╝█████╗  ██████╔╝%b Setup your proxmox environment %b\n' "$(fg RED)" "$(fg MAUVE)" "$RESET"
  printf '%b ██║   ██║██╔══╝  ██╔══██╗   ██║       ██║   ██║██╔══╝  ██╔══██╗██╔══██╗██╔══╝  ██╔══██╗%b Enjoy homelab! 🚀%b\n' "$(fg RED)" "$(fg YELLOW)" "$RESET"
  printf '%b ╚██████╔╝███████╗██║  ██║   ██║       ╚██████╔╝███████╗██║  ██║██████╔╝███████╗██║  ██║%b Have fun with roles! 🎉%b\n' "$(fg RED)" "$(fg GREEN)" "$RESET"
  printf '%b  ╚═════╝ ╚══════╝╚═╝  ╚═╝   ╚═╝        ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝%b\n' "$(fg RED)" "$RESET"
  printf '\n'
}

# ==========================
# Detect OS
# ==========================
detect_os() {
  if [[ -r /etc/os-release ]]; then
    . /etc/os-release
    case "$ID" in
      debian|ubuntu|linuxmint) echo debian ;;
      rhel|centos|rocky|almalinux|fedora) echo rhel ;;
      *) echo debian ;;  # default support path
    esac
  else
    echo debian
  fi
}
PKG_FAMILY="$(detect_os)"

# ===========================
# Root -> Create admin user -> Re-exec
# ===========================
ADMIN_GROUP_DEBIAN="sudo"
ADMIN_GROUP_RHEL="wheel"

validate_username() {
  local u="$1"
  [[ "$u" =~ ^[a-z_][a-z0-9_-]{0,31}$ ]]
}

detect_admin_group() {
  if [[ "$PKG_FAMILY" == debian ]]; then
    echo "$ADMIN_GROUP_DEBIAN"
  else
    echo "$ADMIN_GROUP_RHEL"
  fi
}

ensure_sudo_installed() {
  have_cmd sudo && return 0
  info "Installing sudo..."
  if [[ "$PKG_FAMILY" == debian ]]; then
    apt-get update -y
    DEBIAN_FRONTEND=noninteractive apt-get install -y sudo
  else
    die "This installer currently supports Debian/Ubuntu only for automatic sudo installation."
  fi
}

create_admin_user_if_root() {
  local as_user_flag="${1:-}"
  if [[ $EUID -ne 0 ]]; then
    return 0
  fi
  # If we explicitly came back as user, skip creation
  if [[ "$as_user_flag" == "--as-user" ]]; then
    return 0
  fi

  print_banner
  info "You are running as root. Let's create your non-root admin user."
  is_tty || die "Non-interactive shell detected. Please run with a TTY to create the admin user."

  local USERNAME=""
  while :; do
    read -r -p "Enter new admin username (e.g., gert): " USERNAME
    if [[ -z "${USERNAME:-}" ]]; then
      warn "Username cannot be empty."
      continue
    fi
    if ! validate_username "$USERNAME"; then
      warn "Invalid username. Use lowercase letters, digits, _ or -, max length 32, starting with a letter or _."
      continue
    fi
    if id "$USERNAME" &>/dev/null; then
      warn "User '$USERNAME' already exists."
      read -r -p "Use existing user '$USERNAME'? [y/N]: " yn
      case "${yn,,}" in
        y|yes) break ;;
        *) continue ;;
      esac
    fi
    break
  done

  # Create if missing
  if ! id "$USERNAME" &>/dev/null; then
    if have_cmd adduser; then
      info "Creating user '$USERNAME' (Debian/Ubuntu path)..."
      # Less interactive path:
      adduser --disabled-password --gecos "" "$USERNAME"
      if is_tty; then
        info "Set a password for '$USERNAME':"
        passwd "$USERNAME"
      else
        warn "Non-interactive: leaving '$USERNAME' with disabled password."
      fi
    elif have_cmd useradd; then
      info "Creating user '$USERNAME' (RHEL/Fedora path)..."
      useradd --create-home --shell /bin/bash "$USERNAME"
      info "Set a password for '$USERNAME':"
      passwd "$USERNAME"
    else
      die "Neither adduser nor useradd found."
    fi
  fi

  ensure_sudo_installed

  local ADMIN_GROUP
  ADMIN_GROUP="$(detect_admin_group)"
  if getent group "$ADMIN_GROUP" >/dev/null 2>&1; then
    usermod -aG "$ADMIN_GROUP" "$USERNAME"
    info "Added '$USERNAME' to '$ADMIN_GROUP'."
  else
    warn "Admin group '$ADMIN_GROUP' not found; creating and assigning."
    groupadd "$ADMIN_GROUP"
    usermod -aG "$ADMIN_GROUP" "$USERNAME"
  fi

  # Limited passwordless sudo for bootstrap commands
  echo "$USERNAME ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/apt, /usr/bin/nala, /usr/bin/gh, /usr/bin/git" >/etc/sudoers.d/90-${USERNAME}-bootstrap
  chmod 440 /etc/sudoers.d/90-${USERNAME}-bootstrap
  info "Granted limited passwordless sudo for bootstrap commands."

  # Re-exec this script as the new user (use su as requested)
  local SELF
  SELF="$(script_abs)"
  info "Re-running the installer as '$USERNAME'..."
  exec su -l "$USERNAME" -c "bash -lc 'bash \"$SELF\" --as-user'"
}

# ===========================
# Package Management (uses sudo when not root)
# ===========================
PKG_TOOL="apt"
USE_NALA=false

_sudo() {
  if [[ $EUID -eq 0 ]]; then
    "$@"
  else
    sudo "$@"
  fi
}

install_nala_if_missing() {
  [[ "$PKG_FAMILY" == debian ]] || { warn "Non-Debian OS detected; skipping nala/apt-specific steps."; return 0; }

  if have_cmd nala; then
    USE_NALA=true
    PKG_TOOL="nala"
    return
  fi

  info "Installing nala (faster apt frontend)..."
  _sudo apt-get update -y
  if DEBIAN_FRONTEND=noninteractive _sudo apt-get install -y nala; then
    USE_NALA=true
    PKG_TOOL="nala"
    info "nala installed."
  else
    warn "Failed to install nala; will fall back to apt."
    USE_NALA=false
    PKG_TOOL="apt"
  fi
}

pkg_update_upgrade() {
  if [[ "$PKG_FAMILY" != debian ]]; then
    die "This installer currently targets Debian/Ubuntu (apt/nala)."
  fi
  if $USE_NALA; then
    info "Updating & upgrading via nala..."
    _sudo nala update
    DEBIAN_FRONTEND=noninteractive _sudo nala upgrade -y
  else
    info "Updating & upgrading via apt..."
    _sudo apt-get update -y
    DEBIAN_FRONTEND=noninteractive _sudo apt-get upgrade -y
  fi
}

pkg_install() {
  local pkgs=("$@")
  if [[ "$PKG_FAMILY" != debian ]]; then
    die "This installer currently targets Debian/Ubuntu (apt/nala)."
  fi
  if $USE_NALA; then
    DEBIAN_FRONTEND=noninteractive _sudo nala install -y "${pkgs[@]}" || {
      warn "nala install failed; retrying with apt..."
      DEBIAN_FRONTEND=noninteractive _sudo apt-get install -y "${pkgs[@]}"
    }
  else
    DEBIAN_FRONTEND=noninteractive _sudo apt-get install -y "${pkgs[@]}"
  fi
}

# ===========================
# Env & Inputs
# ===========================
ENV_FILE="${ENV_FILE:-$HOME/.config/dotfilez/env}"

create_env_file_if_missing() {
  if [[ ! -f "$ENV_FILE" ]]; then
    info "Creating $ENV_FILE ..."
    mkdir -p "$(dirname "$ENV_FILE")"
    echo "# dotfilez environment configuration" > "$ENV_FILE"
    chmod 600 "$ENV_FILE"
  fi
}

load_env_if_present() {
  [[ -f "$ENV_FILE" ]] || return 0
  # shellcheck disable=SC1090
  source "$ENV_FILE" || true
  info "Loaded existing env from $ENV_FILE"
}

ask_or_keep() {
  local var_name="$1" prompt="$2"
  local current="${!var_name:-}"
  if [[ -n "$current" ]]; then
    if is_tty; then
      read -r -p "$prompt [$current]: " input || true
      export "$var_name"="${input:-$current}"
    else
      export "$var_name"="$current"
    fi
  else
    if is_tty; then
      read -r -p "$prompt: " input
      export "$var_name"="$input"
    else
      die "Missing required value for $var_name and no TTY to prompt."
    fi
  fi
}

save_env() {
  create_env_file_if_missing
  umask 0177
  local tmp_file
  tmp_file="$(mktemp)"
  cat >"$tmp_file" <<EOF
GIT_NAME=${GIT_NAME}
GIT_EMAIL=${GIT_EMAIL}
EOF
  mv "$tmp_file" "$ENV_FILE"
  chmod 600 "$ENV_FILE"
  info "Saved machine variables to $ENV_FILE"
  export GIT_NAME GIT_EMAIL
}

# ===========================
# Git & GitHub Setup
# ===========================
ensure_gh() {
  if have_cmd gh; then
    info "GitHub CLI (gh) already present."
    return
  fi

  info "Installing GitHub CLI (gh)..."
  # Call the function directly; it wraps sudo internally.
  if pkg_install gh; then
    info "Installed gh via ${PKG_TOOL}."
    return
  fi

  # Debian/Ubuntu: add official GitHub CLI repo and install
  warn "Native package 'gh' not found; setting up GitHub apt repo..."
    # Debian/Ubuntu path: add official GitHub CLI repo and install
  _sudo apt-get update -y
  _sudo apt-get install -y curl ca-certificates gnupg
  _sudo mkdir -p -m 755 /etc/apt/keyrings
  curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
    | _sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg >/dev/null
  _sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg
  # shellcheck disable=SC1091
  . /etc/os-release
  echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages ${VERSION_CODENAME} main" \
    | _sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
  _sudo apt-get update -y
  _sudo apt-get install -y gh || die "Failed to install GitHub CLI."
}

configure_git() {
  # fail fast on missing deps
  command -v git >/dev/null 2>&1 || die "git is not installed."

  # inputs
  : "${GIT_NAME:?GIT_NAME is empty.}"
  : "${GIT_EMAIL:?GIT_EMAIL is empty.}"

  info "Configuring git user identity (global)..."
  git config --global user.name  "$GIT_NAME"
  git config --global user.email "$GIT_EMAIL"
  # optional sensible defaults:
  git config --global init.defaultBranch main >/dev/null 2>&1 || true
  git config --global pull.rebase false        >/dev/null 2>&1 || true

  info "Git is configured."
}

# ===========================
# GitHub Setup
# ===========================
# Prompt for a token (hidden input). Returns via stdout.
prompt_github_token() {
  if ! is_tty; then
    echo "[!] No interactive TTY available. Set GITHUB_TOKEN (or GH_TOKEN) in the environment." >&2
    return 1
  fi
  local token
  echo -n "[?] Enter your GitHub Personal Access Token (input hidden): " >&2
  # -r: raw, -s: silent, -p is not portable across shells; we echo prompt separately.
  read -rs token
  echo >&2   # newline after hidden input
  if [[ -z "$token" ]]; then
    echo "[!] Empty token entered." >&2
    return 1
  fi
  printf '%s' "$token"
}

gh_login_store_token() {
  # Prefer env tokens; otherwise, ask the user.
  local token="${GITHUB_TOKEN:-${GH_TOKEN:-}}"
  if [[ -z "$token" ]]; then
    token="$(prompt_github_token)" || {
      echo "[✗] No token provided; cannot continue GitHub auth."
      return 1
    }
  fi

  # If already authenticated, keep it quick and idempotent.
  if gh auth status -h github.com >/dev/null 2>&1; then
    echo "[+] gh already authenticated to github.com"
    gh auth setup-git || true
    return 0
  fi

  echo "[+] Logging into GitHub CLI and storing credentials…"

  # Keep a copy, then unset env so gh STORES credentials instead of using env.
  local saved_token="$token"
  unset GITHUB_TOKEN GH_TOKEN

  # Clean any stale sessions quietly.
  gh auth logout -h github.com -y >/dev/null 2>&1 || true

  # Feed token via stdin so it never lands in process args or history.
  if ! printf '%s' "$saved_token" | gh auth login --hostname github.com --with-token; then
    echo "[✗] gh auth login failed."
    # Restore env on failure for other tools that might still rely on it.
    export GITHUB_TOKEN="$saved_token"
    return 1
  fi

  # Configure Git to use gh’s credential helper.
  gh auth setup-git || true

  # Optional: restore env for other tooling in this session.
  export GITHUB_TOKEN="$saved_token"

  # Sanity check by hitting the API (confirms token works and scopes allow /user).
  if ! gh api -H "Accept: application/vnd.github+json" /user >/dev/null 2>&1; then
    echo "[✗] Auth appears incomplete; unable to call GitHub API as the authenticated user."
    return 1
  fi

  # Final status check.
  if ! gh auth status -h github.com >/dev/null 2>&1; then
    echo "[✗] gh auth status check failed after login."
    return 1
  fi

  echo "[+] gh authentication configured."
  return 0
}

# ===========================
# Clone Repo
# ===========================
REPO_URL="https://github.com/GertGerber/dotfilez"
CLONE_DIR="$HOME/dotfilez"

clone_or_update_repo() {
  # If path exists but is not a directory, hard stop
  if [[ -e "$CLONE_DIR" && ! -d "$CLONE_DIR" ]]; then
    die "Path $CLONE_DIR exists and is not a directory."
  fi

  # If directory exists, ensure we can write to it
  if [[ -d "$CLONE_DIR" ]]; then
    if [[ ! -w "$CLONE_DIR" ]]; then
      info "Fixing ownership on $CLONE_DIR ..."
      _sudo chown -R "$(id -u)":"$(id -g)" "$CLONE_DIR" || die "Cannot chown $CLONE_DIR"
    fi

    if [[ -d "$CLONE_DIR/.git" ]]; then
      info "Repository already present; pulling latest."
      git -C "$CLONE_DIR" remote set-url origin "$REPO_URL" || true
      git -C "$CLONE_DIR" fetch --all --prune
      git -C "$CLONE_DIR" pull --ff-only
      return
    fi

    # Directory exists but isn't a git repo
    if [[ -z "$(ls -A "$CLONE_DIR")" ]]; then
      info "Empty directory at $CLONE_DIR; cloning into it..."
      git clone "$REPO_URL" "$CLONE_DIR"
    else
      warn "Directory $CLONE_DIR exists and is not empty."
      local ts alt
      ts="$(date +%Y%m%d-%H%M%S)"
      alt="${CLONE_DIR}-${ts}"
      info "Cloning into ${alt} instead..."
      mkdir -p "$alt"
      git clone "$REPO_URL" "$alt"
      CLONE_DIR="$alt"
    fi
    return
  fi

  # Fresh clone
  info "Cloning repository into $CLONE_DIR ..."
  mkdir -p "$CLONE_DIR"
  git clone "$REPO_URL" "$CLONE_DIR"
}

# ===========================
# Post-Clone Hooks
# ===========================
post_clone_actions() {
  info "Post-clone actions section (customize as needed)."
  if ! is_tty; then
    warn "No TTY; skipping interactive post-clone steps."
    return 0
  fi
  if [[ -x "$CLONE_DIR/create_user.sh" ]]; then
    warn "About to run: $CLONE_DIR/create_user.sh (press Enter to continue or Ctrl+C to skip)"
    read -r _
    bash "$CLONE_DIR/create_user.sh" || warn "create_user.sh exited with non-zero status."
  else
    warn "No create_user.sh found at $CLONE_DIR; skipping user creation step."
  fi
}

# ===========================
# Main (user-mode)
# ===========================
PKG_WANTS=(git ca-certificates)

main_user_mode() {
  print_banner

  # Make sure sudo is usable (will prompt once if NOPASSWD not set)
  if [[ $EUID -ne 0 ]]; then
    if ! have_cmd sudo; then
      die "sudo not available; please run as root first so I can install it."
    fi
    sudo -v || die "Unable to obtain sudo privileges."
  fi

  install_nala_if_missing
  pkg_update_upgrade
  pkg_install "${PKG_WANTS[@]}"

  # Gather env (persisted)
  load_env_if_present
  ask_or_keep "GIT_NAME"  "Enter your Git Name"
  ask_or_keep "GIT_EMAIL" "Enter your Git Email"
  save_env

  # Reload saved environment (idempotent)
  if [[ -r "$ENV_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$ENV_FILE"
    info "Reloaded $ENV_FILE into current environment"
  fi

  # GitHub CLI + auth
  ensure_gh
  configure_git

  # GitHub auth (prompt only if interactive)
  if is_tty; then
    gh_login_store_token || warn "GitHub auth not completed; continuing without authenticated gh."
  else
    warn "No TTY; skipping gh login prompt. Set GITHUB_TOKEN in environment for non-interactive runs."
  fi

  # Clone repo
  clone_or_update_repo

  # Post-clone section
  post_clone_actions

  info "All done. This LXC is now primed as your homelab deployment server. 🚀"
}

# ===========================
# Entrypoint
# ===========================
AS_USER_FLAG="${1:-}"
create_admin_user_if_root "$AS_USER_FLAG"
main_user_mode
